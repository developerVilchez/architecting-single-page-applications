# Architecture and State Flow of Single Page Applications

## Lets architect a React application and understand state flow

Our app will display a list of articles. As a user, I will be able to create, delete and like articles.

In this article we will talk about how modern frameworks work and about their declarative nature, touching the concept of state. With this knowledge, we will architect our application from the domain to the view layer.

### Todays frameworks are declarative

React, Angular and most modern front-end frameworks are declarative, encouraging us to use elements of functional programming.

Have you ever seen a flip book?

A flip book is a book with a series of pictures that vary gradually from one page to the next …

Sounds familiar?


Now let’s check a part of React’s definition

Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes …

And a part of Angular’s

Build features quickly with simple, declarative templates. Extend the template language with your own components …

Frameworks help us build apps consisting of views. Views are representations of state. But what is state? 

### State

The state represents every piece of data that changes in an application.

You visit an URL, that’s state, make an Ajax call to retrieve a list of movies, state again, persist info to local storage, ditto, state.

State should be immutable.

### Domain layer

The domain layer describes the state and holds the business logic. It represents the core of our application and should be agnostic to the view layer. Angular, React, Vue, it shouldn’t matter, we should be able to use our domain layer regardless of the framework we choose.

Because we are dealing with immutable architecture, our domain layer will consist of entities and domain services.

Seen as an anti-pattern in OOP, especially in large-scale applications, the anemic domain model is perfectly acceptable when working with immutable data

Having to display a list of articles, the first thing we’ll create is the Article entity.

https://gist.github.com/intojs/5008a2a41196c133a9e8847ae9ee461d

Now let’s create the ArticleService. This domain service will allow us to create instances of the Article class and increment the likes count.





Todays frameworks are declarative
React, Angular and most modern front-end frameworks are declarative, encouraging us to use elements of functional programming.
Have you ever seen a flip book?
A flip book or flick book is a book with a series of pictures that vary gradually from one page to the next, so that when the pages are turned rapidly, the pictures appear to animate by simulating motion or some other change. Wikipedia



Flip bookNow let’s check a part of React’s definition
Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes …
And a part of Angular’s
Build features quickly with simple, declarative templates. Extend the template language with your own components …
Sounds familiar?
Frameworks help us build apps consisting of views. 
Views are representations of state.
But what is state? 
The state
The state represents every piece of data that changes in an application.
You visit an URL, that’s state, make an Ajax call to retrieve a list of movies, that’s state again, you persist info to local storage, ditto, state.
State should be immutable.
Now let’s start architecting!
Our app will display a list of articles. As a user, I will be able to create, delete and like articles.
I’ve chosen Create React App and Flow for type checking. You can find the code supporting this article here.
The domain layer
The domain layer describes the state and holds the business logic. It represents the core of our application and should be agnostic to the view layer. Angular, React, Vue, it shouldn’t matter, we should be able to use our domain layer regardless of the framework we choose.
Domain layerBecause we are dealing with immutable architecture, our domain layer will consist of entities and domain services. 
Controversial in OOP, especially in large-scale applications, the anemic domain model is perfectly acceptable when working with immutable data
Having to display a list of articles, the first thing we’ll model is the Article entity. 
All future objects of type Article are meant to be immutable. Flow can enforce immutability by making every property read-only (see the plus sign before each prop).



Article.jsNow let’s create the ArticleService using factory functions.
The createArticle method will allow us to create frozen objects of type Article. Each new article will have a unique autogenerated id and zero likes, letting us supply only the author and title.
The Object.freeze() method freezes an object: that is, prevents new properties from being added to it
The updateLikes method will help us update the number of likes from an existing article, by returning a copy of it with the new likes count.
Both methods are curried, taking a validator argument and returning another function which deals with the actual business logic, creating articles and updating the number of likes.



ArticleService.jsLet’s take a quick look at the Validators entity and ValidatorService.



Validators.jsPlease take these validations with a grain of salt, just for demo purposes. In JavaScript, checking if an object is, in fact, an object is not that easy. :)



ValidatorService.jsWe now have our domain layer setup!
The nice part is that we can use our code right now, agnostic of any framework.
Let’s see how we can use the ArticleService to create an article about one of my favorite books and update its number of likes.



article-demo.jsThe store layer
The data which results from creating and updating articles represents our application’s state.
We need a place to hold that data, the store being the perfect candidate for the job.
Store layerThe state can easily be modeled by an array of articles.



ArticleState.jsIn our simple application, the ArticleStore implements the publish-subscribe pattern.
The ArticleStore holds the articles and performs the add, remove and update immutable operations on them.
The store solely operates with articles. Only the domain service, ArticleService, can create or update them.
Interested parties can subscribe and unsubscribe to the ArticleStore.
The ArticleStore keeps a list in memory of all subscribers and notifies them of each change.



ArticleStore.jsIn complex applications, I recommend using a state management system like Redux, ngrx, MobX or at least observable data services.
Ok, right now we have the domain and store layers setup.
Let’s create two articles and two subscribers to the store and observe how the subscribers get notified of changes.



Application services
This layer is useful for doing all kinds of operations which are adjacent to the state flow like Ajax calls to retrieve data from the server or state projections.
For whatever reason, a designer comes and demands all article author names to be uppercase.
We know this request is kind of silly and we don’t want to pollute our model with it. So we create the ArticleUiService to handle this feature.
The service will take a piece of state, the author’s name, and project it, returning the uppercase version of the author’s name to the caller.



ArticleUiService.jsLet’s see a demo on how to consume this service!



The view layer
We reached the final layer of our application. We have a fully working application, agnostic of any framework, ready to be put to life by React.
The view layer is composed of presentational and container components.
I won’t get into details about what they are (the diagram below should be quite easy to understand), but I will give you this link on the subject.
The view layerLet’s first build our presentational components and keep our application agnostic of any integrations with the other layers.
There is an art of building presentational components, but that will be the subject of a later article. 
For now, behold our HTML
